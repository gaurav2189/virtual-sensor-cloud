export declare class Tokenizer {
    private _formatString;
    /**
     * Create a new tokenizer
     * @param _formatString (optional) Set the format string
     */
    constructor(_formatString?: string);
    /**
     * Set the format string
     * @param formatString The new string to use for formatting
     */
    setFormatString(formatString: string): void;
    /**
     * Append a new token to the current list of tokens.
     *
     * @param tokenString The string that makes up the token
     * @param tokenArray The existing array of tokens
     * @param raw (optional) If true, don't parse the token but insert it as is
     * @return Token[] The resulting array of tokens.
     */
    private _appendToken(tokenString, tokenArray, raw?);
    /**
     * Parse the internal string and return an array of tokens.
     * @return Token[]
     */
    parseTokens(): Token[];
}
/**
 * Different types of tokens, each for a DateTime "period type" (like year, month, hour etc.)
 */
export declare enum DateTimeTokenType {
    IDENTITY = 0,
    ERA = 1,
    YEAR = 2,
    QUARTER = 3,
    MONTH = 4,
    WEEK = 5,
    DAY = 6,
    WEEKDAY = 7,
    DAYPERIOD = 8,
    HOUR = 9,
    MINUTE = 10,
    SECOND = 11,
    ZONE = 12,
}
/**
 * Basic token
 */
export interface Token {
    /**
     * The type of token
     */
    type: DateTimeTokenType;
    /**
     * The symbol from which the token was parsed
     */
    symbol: string;
    /**
     * The total length of the token
     */
    length: number;
    /**
     * The original string that produced this token
     */
    raw: string;
}
